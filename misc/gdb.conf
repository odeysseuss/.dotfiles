# +----------------+
# + Added Commands +
# +----------------+
# ls -> info (stack, frame, args, locals)
# regs -> info registers
# breaks -> info breakpoints
# asm -> disassemble main
# dis [func] -> disassemble [func]
# xx -> x (replacement)
# d -> display (replacement)

set prompt \001\033[1;38;2;69;133;136m\002gdb \001\033[38;2;215;153;33m\002‚ùØ\001\033[0m\002 
set disassembly-flavor intel
set pagination off
set print pretty on
break main

# +--------------+
# + base aliases +
# +--------------+
define ls
    stack
    frame
    args
    locals
    displays
end
define asm
    dis main
end

# +-------------+
# + disassembly +
# +-------------+
python
import gdb
from pygments import highlight
from pygments.lexers import *
from pygments.formatters import TerminalTrueColorFormatter
from pygments.styles import get_style_by_name, get_all_styles

class TrueColorPrinter:
    def __init__(self):
        self.styles = list(get_all_styles())
        self.style_index = 0
        if 'gruvbox-dark' in self.styles:
            self.style_index = self.styles.index('gruvbox-dark')
        elif 'default' in self.styles:
            self.style_index = self.styles.index('default')

        self.lexer_map = {
            'asm': NasmLexer(),
            'c': CLexer(),
            'cpp': CppLexer(),
            'python': PythonLexer(),
            'rust': RustLexer(),
        }

    def print_colorized(self, text, language='asm'):
        lexer = self.lexer_map.get(language, NasmLexer())
        style = get_style_by_name(self.styles[self.style_index])

        highlighted = highlight(text, lexer, TerminalTrueColorFormatter(style=style))
        print(highlighted, end='')

    def next_style(self):
        self.style_index = (self.style_index + 1) % len(self.styles)
        return self.styles[self.style_index]

tc = TrueColorPrinter()

class ColorDisas(gdb.Command):
    def __init__(self):
        super().__init__("dis", gdb.COMMAND_USER)

    def invoke(self, arg, from_tty):
        try:
            disas_cmd = "disassemble" if not arg else f"disassemble {arg}"
            output = gdb.execute(disas_cmd, to_string=True)
            tc.print_colorized(output, 'asm')
        except gdb.error as e:
            print(f"GDB error: {e}")

ColorDisas()
end

# +----------------------+
# + custom gruvbox theme +
# +----------------------+
python
import gdb
import re

class GruvboxColors:
    # ANSI 256-color codes
    GREEN = '\033[38;5;150m'  # #b8bb26
    BLUE = '\033[38;5;109m'   # #83a598
    PURPLE = '\033[38;5;176m' # #b16286
    YELLOW = '\033[38;5;214m' # #fabd2f
    RED = '\033[38;5;167m'    # #fb4934
    RESET = '\033[0m'
    # True color codes
    # GREEN_TRUE = '\033[38;2;184;187;38m'    # #b8bb26
    # BLUE_TRUE = '\033[38;2;131;165;152m'    # #83a598
    # PURPLE_TRUE = '\033[38;2;177;98;134m'   # #b16286
    # YELLOW_TRUE = '\033[38;2;250;189;47m'   # #fabd2f
    # RED_TRUE = '\033[38;2;251;73;52m'       # #fb4934

def colorize_output(output):
    colors = GruvboxColors()
    lines = output.split('\n')
    result = []

    for line in lines:
        if not line.strip():
            result.append("")
            continue

        colored_line = line

        # register coloring
        register_patterns = [
            # x86/x64
            r'\b(rax|eax|ax|al|ah|rbx|ebx|bx|bl|bh|rcx|ecx|cx|cl|ch|rdx|edx|dx|dl|dh)\b',
            r'\b(rsi|esi|si|sil|rdi|edi|di|dil|rsp|esp|sp|spl|rbp|ebp|bp|bpl)\b',
            r'\b(r8|r8d|r8w|r8b|r9|r9d|r9w|r9b|r10|r10d|r10w|r10b|r11|r11d|r11w|r11b)\b',
            r'\b(r12|r12d|r12w|r12b|r13|r13d|r13w|r13b|r14|r14d|r14w|r14b|r15|r15d|r15w|r15b)\b',
            r'\b(rip|eip|ip|rflags|eflags|flags)\b',
            # ARM64
            r'\b(x[0-3][0-9]|x[0-9]|xzr|wzr|sp|wsp|lr|pc|fp)\b',
            # ARM32
            r'\b(r[0-1][0-9]|r[0-9]|r1[0-5]|cpsr|spsr|fpsr|fpcr|tpidr)\b',
        ]
        register_regex = re.compile('|'.join(register_patterns), re.IGNORECASE)
        colored_line = register_regex.sub(f"{colors.PURPLE}\\g<0>{colors.RESET}", colored_line)

        # address and symbol pattern
        colored_line = re.sub(
            r'^\s*(\b0x[0-9a-fA-F]+\b)(\s*<([^>]+)>)?\s*:',
            f"{colors.GREEN}\\1{colors.RESET}{colors.YELLOW}\\2{colors.RESET}:",
            colored_line
        )

        # hex values regex
        colored_line = re.sub(
            r'\b(0x[0-9a-fA-F]+)\b',
            f"{colors.BLUE}\\1{colors.RESET}",
            colored_line
        )

        # memory access errors
        colored_line = re.sub(
            r'(Cannot access memory at address )((0x)?[0-9a-fA-F]+)',
            f"{colors.RED}Cannot access memory at address {colors.YELLOW}\\2{colors.RESET}",
            colored_line
        )

        result.append(colored_line)

    return '\n'.join(result)

# commands with arguments
class GruvboxCommand(gdb.Command):
    def __init__(self, name, gdb_command, command_type=gdb.COMMAND_USER):
        super(GruvboxCommand, self).__init__(name, command_type)
        self.gdb_command = gdb_command

    def invoke(self, args, from_tty):
        try:
            if self.gdb_command in ['x', 'display'] and args:
                command = f"{self.gdb_command} {args}"
            else:
                command = self.gdb_command
                if args:
                    command = f"{command} {args}"

            output = gdb.execute(command, from_tty=from_tty, to_string=True)
            colorized = colorize_output(output)
            print(colorized, end='')
        except gdb.error as e:
            print(f"Error: {e}")

commands = [
    ("regs", "info registers"),
    ("locals", "info locals"), 
    ("frame", "info frame"),
    ("stack", "info stack"),
    ("args", "info args"),
    ("breaks", "info breakpoints"),
    ("displays", "info display"),
    ("n", "next"),
    ("d", "display"),
    ("c", "continue"),
    ("xx", "x"),
]

for name, gdb_cmd in commands:
    GruvboxCommand(name, gdb_cmd)

end
